<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jean Czerlinski Whitmore" />

<meta name="date" content="2019-08-19" />

<title>Confusion Matrix</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Confusion Matrix</h1>
<h4 class="author">Jean Czerlinski Whitmore</h4>
<h4 class="date">2019-08-19</h4>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(heuristica)</a></code></pre></div>
<p>This is a topic for advanced users.</p>
<p>Predicting between pairs produces categorical output: -1, 0, or 1. A (confusion matrix)[<a href="https://en.wikipedia.org/wiki/Confusion_matrix" class="uri">https://en.wikipedia.org/wiki/Confusion_matrix</a>] counts how many times the predicted category mapped to the various true categories. For example, it can be helpful to see that one heuristic had to guess (predict 0) more often than another. However, there are some quirks to applying confusion matrices to this task, and this vignette explains them.</p>
<ul>
<li>Heuristica functions normally generate predictions for only one unique row pair, e.g. Munich vs. Cologne, but the confusion matrix also needs the “reverse” row pair, e.g. Cologne vs. Munich.</li>
<li>Guesses and ties need to be categorized as 1 or -1 for measures like accuracy.</li>
</ul>
<div id="running-reverse-row-pairs" class="section level1">
<h1>Running reverse row pairs</h1>
<p>Here is some data we will use for an example– the city population data.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span>(<span class="st">&quot;city_population&quot;</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">data_set &lt;-<span class="st"> </span><span class="kw">na.omit</span>(city_population)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">criterion_col &lt;-<span class="st"> </span><span class="dv">3</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">cols_to_fit &lt;-<span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="kw">ncol</span>(data_set)</a></code></pre></div>
<p>Next, the code below fits Take the Best and regression on a subset of this data. (For this example, five rows were selected, but in practice the training rows would be randomly sampled. Furthermore, the predictions would be measured on non-training data.)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">num_training_rows &lt;-<span class="st"> </span><span class="dv">5</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">train_data &lt;-<span class="st"> </span>city_population[<span class="kw">c</span>(<span class="dv">3</span><span class="op">:</span>(<span class="dv">3</span><span class="op">+</span>num_training_rows)),]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">ttb &lt;-<span class="st"> </span><span class="kw">ttbModel</span>(train_data, criterion_col, cols_to_fit)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">reg &lt;-<span class="st"> </span><span class="kw">regModel</span>(train_data, criterion_col, cols_to_fit)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">lreg &lt;-<span class="st"> </span><span class="kw">logRegModel</span>(train_data, criterion_col, cols_to_fit)</a></code></pre></div>
<div id="analyzing-just-forward-row-pairs" class="section level2">
<h2>Analyzing just “forward” row pairs</h2>
<p>We normally use <code>predictPairSummary</code>, but it gains efficiency by appling the functions to only one set of unique row pairs, e.g. Munich vs. Cologne. Below is the output with city names patched in.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">out_fwd_row_pairs_only &lt;-<span class="st"> </span><span class="kw">predictPairSummary</span>(train_data, ttb, reg, lreg)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">fwd_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(out_fwd_row_pairs_only)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">fwd_df<span class="op">$</span>Row1 &lt;-<span class="st"> </span>train_data<span class="op">$</span>Name[fwd_df<span class="op">$</span>Row1]</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">fwd_df<span class="op">$</span>Row2 &lt;-<span class="st"> </span>train_data<span class="op">$</span>Name[fwd_df<span class="op">$</span>Row2]</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">fwd_df</a></code></pre></div>
<pre><code>##         Row1      Row2 CorrectGreater ttbModel regModel logRegModel
## 1     Munich   Cologne              1        0        1          -1
## 2     Munich Frankfurt              1        0        1          -1
## 3     Munich     Essen              1        1        1           1
## 4     Munich  Dortmund              1        1        1           1
## 5     Munich Stuttgart              1        0        0           0
## 6    Cologne Frankfurt              1        0        0           0
## 7    Cologne     Essen              1        1        1           1
## 8    Cologne  Dortmund              1        1        1           1
## 9    Cologne Stuttgart              1        0       -1           1
## 10 Frankfurt     Essen              1        1        1           1
## 11 Frankfurt  Dortmund              1        1        1           1
## 12 Frankfurt Stuttgart              1        0       -1           1
## 13     Essen  Dortmund              1        1        1           1
## 14     Essen Stuttgart              1       -1       -1          -1
## 15  Dortmund Stuttgart              1       -1       -1          -1</code></pre>
<p>Notice this has Munich vs. Cologne but not the other way around, Cologne vs. Frankfurt. Also, because the data set was sorted, all the values of “CorrectGreater” are always 1, never -1. Let’s refer to this as “forward pairs only.” The data is incomplete, but to understand better, let’s generate a confusion matrix for TakeTheBest’s predictions anyway.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">ref_data &lt;-<span class="st"> </span>out_fwd_row_pairs_only[,<span class="st">&quot;CorrectGreater&quot;</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">predictions &lt;-<span class="st"> </span>out_fwd_row_pairs_only[,<span class="st">&quot;ttbModel&quot;</span>]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">ttb_fwd_confusion_matrix &lt;-<span class="st"> </span><span class="kw">confusionMatrixFor_Neg1_0_1</span>(ref_data, predictions)</a></code></pre></div>
<p>Notice that only the last row, named “1,” has non-zero values. That is because the only category in CorrectGreater was “1”. (The function still produces rows for “-1” and “0” to ensure the output always has the same 3x3 shape for analysis.)</p>
<p>The confusion matrix should also have data when CorrectGreater is -1, and we can get this data by generating predictions also for “reverse” row pairs, such as Cologne vs. Munich. Below we will see three ways to do that.</p>
</div>
<div id="generating-reverse-row-pairs" class="section level2">
<h2>Generating “reverse” row pairs</h2>
<p>The most straightforward way to generate both “forward” and “reverse” row pairs is to run predictPairSummary twice, once with the rows in the usual “forward” order and then again with the rows in “reverse”&quot; order, using the reverse order of row indices. Doing this below, we see that the Cologne vs. Munich comparison happened, and its CorrectGreater was indeed -1 (meaning the second city in the pair, Munich, was greater).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">out_fwd_row_pairs_only &lt;-<span class="st"> </span><span class="kw">predictPairSummary</span>(train_data, ttb, reg, lreg)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">train_data_rev_rows &lt;-<span class="st"> </span>train_data[<span class="kw">c</span>(<span class="kw">nrow</span>(train_data)<span class="op">:</span><span class="dv">1</span>),]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">out_rev_row_pairs_only &lt;-<span class="st"> </span><span class="kw">predictPairSummary</span>(train_data_rev_rows, ttb, reg, lreg)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">out_both &lt;-<span class="st"> </span><span class="kw">rbind</span>(out_fwd_row_pairs_only, out_rev_row_pairs_only)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">both_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(out_both)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">both_df<span class="op">$</span>Row1 &lt;-<span class="st"> </span>train_data<span class="op">$</span>Name[both_df<span class="op">$</span>Row1]</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">both_df<span class="op">$</span>Row2 &lt;-<span class="st"> </span>train_data<span class="op">$</span>Name[both_df<span class="op">$</span>Row2]</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">both_df</a></code></pre></div>
<pre><code>##         Row1      Row2 CorrectGreater ttbModel regModel logRegModel
## 1     Munich   Cologne              1        0        1          -1
## 2     Munich Frankfurt              1        0        1          -1
## 3     Munich     Essen              1        1        1           1
## 4     Munich  Dortmund              1        1        1           1
## 5     Munich Stuttgart              1        0        0           0
## 6    Cologne Frankfurt              1        0        0           0
## 7    Cologne     Essen              1        1        1           1
## 8    Cologne  Dortmund              1        1        1           1
## 9    Cologne Stuttgart              1        0       -1           1
## 10 Frankfurt     Essen              1        1        1           1
## 11 Frankfurt  Dortmund              1        1        1           1
## 12 Frankfurt Stuttgart              1        0       -1           1
## 13     Essen  Dortmund              1        1        1           1
## 14     Essen Stuttgart              1       -1       -1          -1
## 15  Dortmund Stuttgart              1       -1       -1          -1
## 16    Munich   Cologne             -1        1        1           1
## 17    Munich Frankfurt             -1        1        1           1
## 18    Munich     Essen             -1        0        1          -1
## 19    Munich  Dortmund             -1        0        1          -1
## 20    Munich Stuttgart             -1        0        0           0
## 21   Cologne Frankfurt             -1       -1       -1          -1
## 22   Cologne     Essen             -1       -1       -1          -1
## 23   Cologne  Dortmund             -1       -1       -1          -1
## 24   Cologne Stuttgart             -1       -1       -1          -1
## 25 Frankfurt     Essen             -1       -1       -1          -1
## 26 Frankfurt  Dortmund             -1       -1       -1          -1
## 27 Frankfurt Stuttgart             -1       -1       -1          -1
## 28     Essen  Dortmund             -1        0        0           0
## 29     Essen Stuttgart             -1        0       -1           1
## 30  Dortmund Stuttgart             -1        0       -1           1</code></pre>
<p>With that output, we can generate a complete confusion matrix for Take The Best. It has non-zero data in both the first “-1” row and the last “1” row.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">ref_data &lt;-<span class="st"> </span>out_both[,<span class="st">&quot;CorrectGreater&quot;</span>]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">predictions &lt;-<span class="st"> </span>out_both[,<span class="st">&quot;ttbModel&quot;</span>]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">confusionMatrixFor_Neg1_0_1</span>(ref_data, predictions)</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  7 6 2
##      0   0 0 0
##      1   2 6 7</code></pre>
<p>You might notice a symmetry in this confusion matrix. For example, there are 7 cases where TTB accurately predicted 1 where the CorrectGreater value was 1. When these rows were reversed, they resulted in 7 cases where TTB accurately predicted -1 where the CorrectGreater value was -1. This happens because TTB is a symmetric model, meaning predictPair(Row1, Row2) = - predictPair(Row2, Row1). All the models included in heuristica have this property, which <code>percentCorrectSummary</code> exploits– that’s why it can get results with just the forward row pairs.</p>
<p>We can also exploit model symmetry in calculating the confusion matrix. Calculate the confusion matrix based on just the forward row pairs, and you can infer the results for the reverse row pairs. Below is an example calculation.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">ttb_fwd_confusion_matrix <span class="op">+</span><span class="st"> </span><span class="kw">reverseRowsAndReverseColumns</span>(ttb_fwd_confusion_matrix)</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  7 6 2
##      0   0 0 0
##      1   2 6 7</code></pre>
<p>Yet another way to calculate this complete confusion matrix is to use the more flexible <code>rowPairApplyList</code> function (rather than <code>predictPairSummary</code>) to generate the prediction data. Specifically, set the optional parameter <code>also_reverse_row_pairs=TRUE</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">out &lt;-<span class="st"> </span><span class="kw">rowPairApplyList</span>(train_data, <span class="kw">list</span>(<span class="kw">correctGreater</span>(criterion_col), <span class="kw">heuristics</span>(ttb, reg, lreg)), <span class="dt">also_reverse_row_pairs=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">out</a></code></pre></div>
<pre><code>##       CorrectGreater ttbModel regModel logRegModel
##  [1,]              1        0        1          -1
##  [2,]              1        0        1          -1
##  [3,]              1        1        1           1
##  [4,]              1        1        1           1
##  [5,]              1        0        0           0
##  [6,]              1        0        0           0
##  [7,]              1        1        1           1
##  [8,]              1        1        1           1
##  [9,]              1        0       -1           1
## [10,]              1        1        1           1
## [11,]              1        1        1           1
## [12,]              1        0       -1           1
## [13,]              1        1        1           1
## [14,]              1       -1       -1          -1
## [15,]              1       -1       -1          -1
## [16,]             -1        1        1           1
## [17,]             -1        1        1           1
## [18,]             -1        0        1          -1
## [19,]             -1        0        1          -1
## [20,]             -1        0        0           0
## [21,]             -1       -1       -1          -1
## [22,]             -1       -1       -1          -1
## [23,]             -1       -1       -1          -1
## [24,]             -1       -1       -1          -1
## [25,]             -1       -1       -1          -1
## [26,]             -1       -1       -1          -1
## [27,]             -1       -1       -1          -1
## [28,]             -1        0        0           0
## [29,]             -1        0       -1           1
## [30,]             -1        0       -1           1</code></pre>
<p>Calculating Take The Best’s confusion matrix from this output produces the same result as above.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">ref_data &lt;-<span class="st"> </span>out[,<span class="st">&quot;CorrectGreater&quot;</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">predictions &lt;-<span class="st"> </span>out[,<span class="st">&quot;ttbModel&quot;</span>]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="kw">confusionMatrixFor_Neg1_0_1</span>(ref_data, predictions)</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  7 6 2
##      0   0 0 0
##      1   2 6 7</code></pre>
<p>Note that the flag does <em>not</em> assume the heuristic is symmetric– it actually applies the prediction function to reversed row pairs. So those were three ways to calculate the confusion matrix.</p>
</div>
<div id="analyzing-output-of-the-three-models" class="section level2">
<h2>Analyzing output of the three models</h2>
<p>Now let’s analyze the confusion matrices for the three models we fit to the subset of the city population data. Below are their 3x3 confusion matrices based on the predictions with <code>also_reverse_row_pairs=TRUE</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">confusion_matrix_3x3_ttb &lt;-<span class="st"> </span><span class="kw">confusionMatrixFor_Neg1_0_1</span>(out[,<span class="st">&quot;CorrectGreater&quot;</span>], out[,<span class="st">&quot;ttbModel&quot;</span>])</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">confusion_matrix_3x3_ttb</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  7 6 2
##      0   0 0 0
##      1   2 6 7</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">confusion_matrix_3x3_reg &lt;-<span class="st"> </span><span class="kw">confusionMatrixFor_Neg1_0_1</span>(out[,<span class="st">&quot;CorrectGreater&quot;</span>], out[,<span class="st">&quot;regModel&quot;</span>])</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">confusion_matrix_3x3_reg</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  9 2 4
##      0   0 0 0
##      1   4 2 9</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1">confusion_matrix_3x3_lreg &lt;-<span class="st"> </span><span class="kw">confusionMatrixFor_Neg1_0_1</span>(out[,<span class="st">&quot;CorrectGreater&quot;</span>], out[,<span class="st">&quot;logRegModel&quot;</span>])</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">confusion_matrix_3x3_lreg</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  9 2 4
##      0   0 0 0
##      1   4 2 9</code></pre>
<p>Take The Best does worse on this data because it guesses much more than the regression models– 12 guesses (6+6) vs. only 4 (2+2). When TTB is not guessing, it is highly accurate, getting 7 correct for every 2 incorrect, an excellent ratio of 3.5. The regression models have a non-guessing correctness ration of 9 vs. 4 = 2.25. We will see in the next section the impact these numbers have on the percent correct, but we will need a way to deal with guesses to do that.</p>
<p>It interesting that regression and logistic regression have the exact same confusion matrix, even though the output showed they sometimes disagreed. Below are the cases where they diagreed, and we see that their correct and incorrect values exactly balance out. Notice also that these were rows that Take The Best guessed on, deeming them too hard to distinguish.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">out_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(out)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">out_df[out_df<span class="op">$</span>regModel <span class="op">!=</span><span class="st"> </span>out_df<span class="op">$</span>logRegModel,]</a></code></pre></div>
<pre><code>##    CorrectGreater ttbModel regModel logRegModel
## 1               1        0        1          -1
## 2               1        0        1          -1
## 9               1        0       -1           1
## 12              1        0       -1           1
## 18             -1        0        1          -1
## 19             -1        0        1          -1
## 29             -1        0       -1           1
## 30             -1        0       -1           1</code></pre>
</div>
</div>
<div id="distributing-guesses-and-ties" class="section level1">
<h1>Distributing guesses and ties</h1>
<p>In order to calculate percentCorrect from the confusion matrix, we need to handle the guesses. Heuristica offers a function that allocates these by their expected values, so half the guess counts are moved to +1 and half are moved to -1. Then the guess row can be removed. (Note that there are other ways to handle guesses, e.g. counting them all as correct or not counting them at all.)</p>
<p>Below we see the original matrix and how it looks after having guesses distributed by <code>collapseConfusionMatrix3x3To2x2</code>. (Likewise it distributes half the ties to +1 and half to -1, although in this data set there were no ties.)</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">confusion_matrix_3x3_ttb</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  7 6 2
##      0   0 0 0
##      1   2 6 7</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">confusion_matrix_ttb &lt;-<span class="st"> </span><span class="kw">collapseConfusionMatrix3x3To2x2</span>(confusion_matrix_3x3_ttb)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">confusion_matrix_ttb</a></code></pre></div>
<pre><code>##        predictions
## correct -1  1
##      -1 10  5
##      1   5 10</code></pre>
<p>The number of correct predictions is along the diagonal– where correct was -1 and the prediction was -1 and where correct was 1 and the prediction was 1. So the percent correct is the sum of the diagonal divided by the sum of the whole matrix.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1">percent_correct_ttb &lt;-<span class="st"> </span><span class="dv">100</span> <span class="op">*</span><span class="kw">sum</span>(<span class="kw">diag</span>(confusion_matrix_ttb)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(confusion_matrix_ttb)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">percent_correct_ttb</a></code></pre></div>
<pre><code>## [1] 66.66667</code></pre>
<p>This agrees with the output of heuristica’s one-step <code>percentCorrect</code> function would tell us.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">percentCorrect</span>(train_data, ttb)</a></code></pre></div>
<pre><code>##   ttbModel
## 1 66.66667</code></pre>
<p>Now distribute guesses for the regression models. Funnily enough, we end up with the same confusion matrix and accuracy as Take The Best. In other words, the additional “predictions” that regression models made did no better than Take The Best’s guesses! (Perhaps a regression user would be “overconfident.”)</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">confusion_matrix_3x3_reg</a></code></pre></div>
<pre><code>##        predictions
## correct -1 0 1
##      -1  9 2 4
##      0   0 0 0
##      1   4 2 9</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1">confusion_matrix_reg &lt;-<span class="st"> </span><span class="kw">collapseConfusionMatrix3x3To2x2</span>(confusion_matrix_3x3_reg)</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">confusion_matrix_reg</a></code></pre></div>
<pre><code>##        predictions
## correct -1  1
##      -1 10  5
##      1   5 10</code></pre>
<div id="alternatives" class="section level2">
<h2>Alternatives</h2>
<p>Note that thre are altenative options. Simsek and Buckman (2015) counted all ties as correct rather than half correct. They did, however, have the same handling of guesses, counting half of guesses as correct. Citation: Simsek, Özgür, and Buckmann, Marcus. (2015). Learning From Small Samples: An Analysis of Simple Decision Heuristics. Advances in Neural Information Processing Systems 28.</p>
</div>
<div id="statistics" class="section level2">
<h2>Statistics</h2>
<p>So why bother with the confusion matrix? Because it gives us insight into the details of how the algorithms achieve their percent correct. We now know that Take The Best guessed 3 times more on this data set than regressions models. And with the confusion matrix, we can calculate a variety of stats in addition to accuracy:</p>
<ul>
<li>accuracy = (true positive + true negatve) / all (100 times this is the same as percentCorrect)</li>
<li>sensitivity = true pasitive rate = true positive / all positive (sensitivity is also called recall)</li>
<li>specificity = true negative rate = true negative / all negative</li>
<li>precision = positive predictive velue = true positive rate</li>
</ul>
<p>Since all the models ended up with the same confusion matrix, we only need to calculate these stats once. But when models differ, the stats can be enlightening.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">statsFromConfusionMatrix</span>(confusion_matrix_ttb)</a></code></pre></div>
<pre><code>## $accuracy
## [1] 0.6666667
## 
## $sensitivity
## [1] 0.6666667
## 
## $specificity
## [1] 0.6666667
## 
## $precision
## [1] 0.6666667</code></pre>
<p>Surprised? Symmetric models will always have this pattern where all four values are the same. Why? Suppose the forward row pair matrix looks like this:</p>
<table>
<tr>
<td>
a
</td>
<td>
b
</td>
</tr>
<tr>
<td>
c
</td>
<td>
d
</td>
</tr>
</table>
<p>The as described above, running the reverse row pairs will produce counts with rows and columns reversed:</p>
<table>
<tr>
<td>
d
</td>
<td>
c
</td>
</tr>
<tr>
<td>
b
</td>
<td>
a
</td>
</tr>
</table>
<p>Summing these gives the total counts:</p>
<table>
<tr>
<td>
a + d
</td>
<td>
b + c
</td>
</tr>
<tr>
<td>
b + c
</td>
<td>
a + d
</td>
</tr>
</table>
<p>All the statistics on this matrix– accuracy, sensitivity, specificity, and precision, reduce to (a+d) / (a + b + c + d).</p>
</div>
</div>
<div id="heuristicas-deterministic-percent-correct" class="section level1">
<h1>Heuristica’s deterministic percent correct</h1>
<p>Heuristica <code>percentCorrect</code> function handles a model’s guess predictions as described in this vignette– it assigns half to 1 and half to -1. The advantage is that the output of <code>percentCorrect</code> is deterministic even for heuristics that guess, and it matches the long-run average, so results converge with fewer simulations. In this vignette’s 5 cities example, using the expected value gave Take The Best the exact same percentCorrect (2/3) as regression and logistic regression. But in practice, if Take The Best really guessed, sometimes it would do better than 2/3 and sometimes it would do worse. Users who wish to study this sort of variance will have to write their own guess-handling functions based on the output of predictPairSummary or rowPairApply.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
